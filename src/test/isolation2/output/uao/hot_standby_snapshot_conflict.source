---------------------------------------------------------------------
-- Test for snapshot conflict that involve AO/CO tables on hot standby.
---------------------------------------------------------------------

-- Our mechanism for AO/CO snapshot conflict is to make sure we emit latestRemovedXid before
-- we actually vacuum AO/CO segfiles (see ao_vacuum_rel_recycle_dead_segments). The AO/CO
-- truncate WAL or the index vacuum WAL has no latestRemovedXid information. So it is key
-- to test that the standby is not replaying those WALs unexpectedly.
--
-- During this test, we'll check whether it is the latestRemovedXid emitted by AO vacuum
-- that conflicts with the standby query. We do that by injecting a fault that will only be
-- hit by the specific relfilenode of the AO table, which can only happen with the emit record.

-- Helper function to inject fault in the snapshot conflict resolution path for the relfilenode
-- of our test table. We will only create conflict on seg0.
create or replace function inject_resolve_snapshot_fault(p_relname text) returns void as $$ declare v_relfilenode oid;	/* in func */ begin	/* in func */ select relfilenode into v_relfilenode from gp_dist_random('pg_class') where relname = p_relname and gp_segment_id = 0;	/* in func */ perform gp_inject_fault('resolve_snapshot_conflict', 'skip', '', '', v_relfilenode::regclass::text, 1, -1, 0, dbid, -1)	/* in func */ from gp_segment_configuration	/* in func */ where content = 0 and role = 'm';	/* in func */ end;	/* in func */ $$ language plpgsql;
CREATE FUNCTION

-- start_matchsubs
-- m/table name:'\d+'/
-- s/table name:'\d+'//
-- m/gp_inject_fault\s+/
-- m/gp_inject_fault//
-- end_matchsubs

-- A VACUUM includes updating pg_stat_last_operation for metadata tracking. Such updates
-- may involve pruning the heap pages which might also emit latestRemovedXid. In order
-- for such updates to not affect our testing, we skip them in this test.
select gp_inject_fault_infinite('skip_meta_track_update', 'skip',dbid) from gp_segment_configuration where content = -1 and role = 'p';
 gp_inject_fault_infinite 
--------------------------
 Success:                 
(1 row)

-- the test starts with no defer in vacuum (GUC being 0)
show vacuum_defer_cleanup_age;
 vacuum_defer_cleanup_age 
--------------------------
 0                        
(1 row)
-- the test assumes we have remote_apply, otherwise the test result is totally unpredictable.
show synchronous_commit;
 synchronous_commit 
--------------------
 remote_apply       
(1 row)

create table hs_qc_@amname@(a int) using @amname@;
CREATE TABLE
create index on hs_qc_@amname@(a);
CREATE INDEX

---------------------------------------------------------------------
-- Basic case: vacuum conflicts with standby query
---------------------------------------------------------------------
1: insert into hs_qc_@amname@ select * from generate_series(1,10);
INSERT 0 10

-- take the snapshot on the standby first
-1S: begin transaction isolation level repeatable read;
BEGIN
-1S: select count(*) from hs_qc_@amname@;
 count 
-------
 10    
(1 row)

1: select inject_resolve_snapshot_fault('hs_qc_@amname@');
 inject_resolve_snapshot_fault 
-------------------------------
                               
(1 row)

-- delete & vacuum rows on the primary
1: delete from hs_qc_@amname@ where a = 2;
DELETE 1
1: vacuum hs_qc_@amname@;
VACUUM

-- The standby query should have conflict and is cancelled
-1S: select count(*) from hs_qc_@amname@;
DETAIL:  User query might have needed to see row versions that must be removed.
ERROR:  terminating connection due to conflict with recovery
HINT:  In a moment you should be able to reconnect to the database and repeat your command.
-1S: end;
ROLLBACK

-- there should be 1 hit
1: select gp_inject_fault('resolve_snapshot_conflict', 'status', dbid) from gp_segment_configuration where content = 0 and role = 'm';
 gp_inject_fault                                                                                                                                                                                                                       
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 
 Success: fault name:'resolve_snapshot_conflict' fault type:'skip' ddl statement:'' database name:''  start occurrence:'1' end occurrence:'-1' extra arg:'0' fault injection state:'triggered'  num times hit:'1' 
(1 row)
1: select gp_inject_fault('resolve_snapshot_conflict', 'reset', dbid) from gp_segment_configuration where content = 0 and role = 'm';
 gp_inject_fault 
-----------------
 Success:        
(1 row)

1: truncate hs_qc_@amname@;
TRUNCATE TABLE

---------------------------------------------------------------------
-- Primary's initial vacuum does not truncate the AO segfile due to
-- concurrent query on the primary. The standby won't get conflict in
-- that vacuum, but will do in future vacuum that truncates the segfile.
---------------------------------------------------------------------
1: insert into hs_qc_@amname@ select * from generate_series(1,10);
INSERT 0 10
2: begin transaction isolation level repeatable read;
BEGIN
2: select count(*) from hs_qc_@amname@;
 count 
-------
 10    
(1 row)

-1S: begin transaction isolation level repeatable read;
BEGIN
-1S: select count(*) from hs_qc_@amname@;
 count 
-------
 10    
(1 row)

1: select inject_resolve_snapshot_fault('hs_qc_@amname@');
 inject_resolve_snapshot_fault 
-------------------------------
                               
(1 row)

-- the initial vacuum won't truncate the segfile
1: delete from hs_qc_@amname@ where a = 2;
DELETE 1
1: vacuum hs_qc_@amname@;
VACUUM

-- the standby query is fine
-1S: select count(*) from hs_qc_@amname@;
 count 
-------
 10    
(1 row)

-- there should be no hit yet
1: select gp_inject_fault('resolve_snapshot_conflict', 'status', dbid) from gp_segment_configuration where content = 0 and role = 'm';
 gp_inject_fault                                                                                                                                                                                                                 
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 
 Success: fault name:'resolve_snapshot_conflict' fault type:'skip' ddl statement:'' database name:''  start occurrence:'1' end occurrence:'-1' extra arg:'0' fault injection state:'set'  num times hit:'0' 
(1 row)

-- now w/o the concurrent query, the vacuum would go through
2: end;
COMMIT
1: vacuum hs_qc_@amname@;
VACUUM

-- and the standby query gets cancelled
-1S: select count(*) from hs_qc_@amname@;
DETAIL:  User query might have needed to see row versions that must be removed.
ERROR:  terminating connection due to conflict with recovery
HINT:  In a moment you should be able to reconnect to the database and repeat your command.
-1S: end;
ROLLBACK

-- there should be 1 hit
1: select gp_inject_fault('resolve_snapshot_conflict', 'status', dbid) from gp_segment_configuration where content = 0 and role = 'm';
 gp_inject_fault                                                                                                                                                                                                                       
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 
 Success: fault name:'resolve_snapshot_conflict' fault type:'skip' ddl statement:'' database name:''  start occurrence:'1' end occurrence:'-1' extra arg:'0' fault injection state:'triggered'  num times hit:'1' 
(1 row)
1: select gp_inject_fault('resolve_snapshot_conflict', 'reset', dbid) from gp_segment_configuration where content = 0 and role = 'm';
 gp_inject_fault 
-----------------
 Success:        
(1 row)

1: truncate hs_qc_@amname@;
TRUNCATE TABLE

---------------------------------------------------------------------
-- VACUUM of a table that standby is NOT accessing can still cause conflict,
-- since the query conflict is based on snapshot, w/o regard to specific relations.
---------------------------------------------------------------------
1: insert into hs_qc_@amname@ select * from generate_series(1,10);
INSERT 0 10
1: create table hs_qc_@amname@_other(a int) using @amname@;
CREATE TABLE

-- select from a different table
-1S: begin transaction isolation level repeatable read;
BEGIN
-1S: select count(*) from hs_qc_@amname@_other;
 count 
-------
 0     
(1 row)

1: select inject_resolve_snapshot_fault('hs_qc_@amname@');
 inject_resolve_snapshot_fault 
-------------------------------
                               
(1 row)

1: delete from hs_qc_@amname@ where a = 2;
DELETE 1
1: vacuum hs_qc_@amname@;
VACUUM

-- it still conflicts
-1S: select count(*) from hs_qc_@amname@_other;
DETAIL:  User query might have needed to see row versions that must be removed.
ERROR:  terminating connection due to conflict with recovery
HINT:  In a moment you should be able to reconnect to the database and repeat your command.
-1S: end;
ROLLBACK

-- there should be 1 hit
1: select gp_inject_fault('resolve_snapshot_conflict', 'status', dbid) from gp_segment_configuration where content = 0 and role = 'm';
 gp_inject_fault                                                                                                                                                                                                                       
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 
 Success: fault name:'resolve_snapshot_conflict' fault type:'skip' ddl statement:'' database name:''  start occurrence:'1' end occurrence:'-1' extra arg:'0' fault injection state:'triggered'  num times hit:'1' 
(1 row)
1: select gp_inject_fault('resolve_snapshot_conflict', 'reset', dbid) from gp_segment_configuration where content = 0 and role = 'm';
 gp_inject_fault 
-----------------
 Success:        
(1 row)

1: truncate hs_qc_@amname@;
TRUNCATE TABLE

---------------------------------------------------------------------
-- VACUUM in a different database won't cause conflict.
---------------------------------------------------------------------
1: create database a_different_db;
CREATE DATABASE
1q: ... <quitting>
1:@db_name a_different_db: create table a_different_t(a int) using @amname@;
CREATE TABLE
1:@db_name a_different_db: insert into a_different_t select * from generate_series(1,10);
INSERT 0 10

-1S: begin transaction isolation level repeatable read;
BEGIN
-1S: select count(*) from hs_qc_@amname@;
 count 
-------
 0     
(1 row)

1:@db_name a_different_db: delete from a_different_t;
DELETE 10
1:@db_name a_different_db: vacuum a_different_t;
VACUUM

-- won't conflict
-1S: select count(*) from hs_qc_@amname@;
 count 
-------
 0     
(1 row)

1q: ... <quitting>
1: drop database a_different_db;
DROP DATABASE

---------------------------------------------------------------------
-- Test that the vacuum_defer_cleanup_age GUC is respected
--
-- XXX: upstream has removed this GUC (1118cd37eb61e6a2428f457a8b2026a7bb3f801a). We should consider doing that too.
-- But for the current being, it's the only thing that we can rely on for mitigating conflict for
-- archive recovery hot standby (e.g. Disaster Reocvery cluster).
---------------------------------------------------------------------
!\retcode gpconfig -c vacuum_defer_cleanup_age -v 1;
(exited with code 0)
!\retcode gpstop -u;
(exited with code 0)

1: insert into hs_qc_@amname@ select * from generate_series(1,10);
INSERT 0 10

-1S: begin transaction isolation level repeatable read;
BEGIN
-1S: select count(*) from hs_qc_@amname@;
 count 
-------
 0     
(1 row)

-- VACUUM won't cleanup this table since the DELETE is still within vacuum_defer_cleanup_age
1: delete from hs_qc_@amname@;
DELETE 10
1: vacuum hs_qc_@amname@;
VACUUM

-- hot standby can still query the table
-1S: select count(*) from hs_qc_@amname@;
 count 
-------
 0     
(1 row)

-- only if the age is reached, hot standby will get the conflict
1: create temp table tt1(a int);
CREATE TABLE
1: vacuum hs_qc_@amname@;
VACUUM

-1S: select count(*) from hs_qc_@amname@;
DETAIL:  User query might have needed to see row versions that must be removed.
ERROR:  terminating connection due to conflict with recovery
HINT:  In a moment you should be able to reconnect to the database and repeat your command.
-1S: end;
ROLLBACK

!\retcode gpconfig -r vacuum_defer_cleanup_age;
(exited with code 0)
!\retcode gpstop -u;
(exited with code 0)

-- reset faults
select gp_inject_fault('skip_meta_track_update', 'reset', dbid) from gp_segment_configuration where content = -1 and role = 'p';
 gp_inject_fault 
-----------------
 Success:        
(1 row)

